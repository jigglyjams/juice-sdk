/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type JBFundingCycleStruct = {
  number: BigNumberish;
  configuration: BigNumberish;
  basedOn: BigNumberish;
  start: BigNumberish;
  duration: BigNumberish;
  weight: BigNumberish;
  discountRate: BigNumberish;
  ballot: string;
  metadata: BigNumberish;
};

export type JBFundingCycleStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  string,
  BigNumber
] & {
  number: BigNumber;
  configuration: BigNumber;
  basedOn: BigNumber;
  start: BigNumber;
  duration: BigNumber;
  weight: BigNumber;
  discountRate: BigNumber;
  ballot: string;
  metadata: BigNumber;
};

export type JBTokenAmountStruct = {
  token: string;
  value: BigNumberish;
  decimals: BigNumberish;
  currency: BigNumberish;
};

export type JBTokenAmountStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  token: string;
  value: BigNumber;
  decimals: BigNumber;
  currency: BigNumber;
};

export type JBPayDelegateAllocationStruct = {
  delegate: string;
  amount: BigNumberish;
};

export type JBPayDelegateAllocationStructOutput = [string, BigNumber] & {
  delegate: string;
  amount: BigNumber;
};

export type JBRedemptionDelegateAllocationStruct = {
  delegate: string;
  amount: BigNumberish;
};

export type JBRedemptionDelegateAllocationStructOutput = [string, BigNumber] & {
  delegate: string;
  amount: BigNumber;
};

export interface JBSingleTokenPaymentTerminalStore3_1Interface
  extends utils.Interface {
  functions: {
    "balanceOf(address,uint256)": FunctionFragment;
    "currentOverflowOf(address,uint256)": FunctionFragment;
    "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)": FunctionFragment;
    "currentReclaimableOverflowOf(address,uint256,uint256,bool)": FunctionFragment;
    "currentTotalOverflowOf(uint256,uint256,uint256)": FunctionFragment;
    "directory()": FunctionFragment;
    "fundingCycleStore()": FunctionFragment;
    "prices()": FunctionFragment;
    "recordAddedBalanceFor(uint256,uint256)": FunctionFragment;
    "recordDistributionFor(uint256,uint256,uint256)": FunctionFragment;
    "recordMigration(uint256)": FunctionFragment;
    "recordPaymentFrom(address,(address,uint256,uint256,uint256),uint256,uint256,address,string,bytes)": FunctionFragment;
    "recordRedemptionFor(address,uint256,uint256,string,bytes)": FunctionFragment;
    "recordUsedAllowanceOf(uint256,uint256,uint256)": FunctionFragment;
    "usedDistributionLimitOf(address,uint256,uint256)": FunctionFragment;
    "usedOverflowAllowanceOf(address,uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "balanceOf"
      | "currentOverflowOf"
      | "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)"
      | "currentReclaimableOverflowOf(address,uint256,uint256,bool)"
      | "currentTotalOverflowOf"
      | "directory"
      | "fundingCycleStore"
      | "prices"
      | "recordAddedBalanceFor"
      | "recordDistributionFor"
      | "recordMigration"
      | "recordPaymentFrom"
      | "recordRedemptionFor"
      | "recordUsedAllowanceOf"
      | "usedDistributionLimitOf"
      | "usedOverflowAllowanceOf"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "currentOverflowOf",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "currentReclaimableOverflowOf(address,uint256,uint256,bool)",
    values: [string, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "currentTotalOverflowOf",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "directory", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "fundingCycleStore",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "prices", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "recordAddedBalanceFor",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "recordDistributionFor",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "recordMigration",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "recordPaymentFrom",
    values: [
      string,
      JBTokenAmountStruct,
      BigNumberish,
      BigNumberish,
      string,
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "recordRedemptionFor",
    values: [string, BigNumberish, BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "recordUsedAllowanceOf",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "usedDistributionLimitOf",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "usedOverflowAllowanceOf",
    values: [string, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "currentOverflowOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentReclaimableOverflowOf(address,uint256,uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentTotalOverflowOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "directory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fundingCycleStore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "prices", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "recordAddedBalanceFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recordDistributionFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recordMigration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recordPaymentFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recordRedemptionFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recordUsedAllowanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedDistributionLimitOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedOverflowAllowanceOf",
    data: BytesLike
  ): Result;

  events: {};
}

export interface JBSingleTokenPaymentTerminalStore3_1 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: JBSingleTokenPaymentTerminalStore3_1Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * The amount of tokens that each project has for each terminal, in terms of the terminal's token.
     */
    balanceOf(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * Gets the current overflowed amount in a terminal for a specified project.
     * @param _projectId The ID of the project to get overflow for.
     * @param _terminal The terminal for which the overflow is being calculated.
     */
    currentOverflowOf(
      _terminal: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
     * @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     */
    "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)"(
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _totalSupply: BigNumberish,
      _overflow: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.The current reclaimable overflow is returned in terms of the specified terminal's currency.The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _terminal The terminal from which the reclaimable amount would come.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
     */
    "currentReclaimableOverflowOf(address,uint256,uint256,bool)"(
      _terminal: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _useTotalOverflow: boolean,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Gets the current overflowed amount for a specified project across all terminals.
     * @param _currency The currency that the total overflow should be in terms of.
     * @param _decimals The number of decimals that the fixed point overflow should include.
     * @param _projectId The ID of the project to get total overflow for.
     */
    currentTotalOverflowOf(
      _projectId: BigNumberish,
      _decimals: BigNumberish,
      _currency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The contract storing all funding cycle configurations.
     */
    fundingCycleStore(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly added funds for the project.
     * @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
     * @param _projectId The ID of the project to which the funds being added belong.
     */
    recordAddedBalanceFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly distributed funds for a project.
     * @param _amount The amount to use from the distribution limit, as a fixed point number.
     * @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
     * @param _projectId The ID of the project that is having funds distributed.
     */
    recordDistributionFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
     * Records the migration of funds from this store.
     * @param _projectId The ID of the project being migrated.
     */
    recordMigration(
      _projectId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    recordPaymentFrom(
      _payer: string,
      _amount: JBTokenAmountStruct,
      _projectId: BigNumberish,
      _baseWeightCurrency: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
     * Records newly redeemed tokens of a project.
     * @param _holder The account that is having its tokens redeemed.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, if one is provided.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    recordRedemptionFor(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly used allowance funds of a project.
     * @param _amount The amount to use from the allowance, as a fixed point number.
     * @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
     * @param _projectId The ID of the project to use the allowance of.
     */
    recordUsedAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
     */
    usedDistributionLimitOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
     */
    usedOverflowAllowanceOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  /**
   * The amount of tokens that each project has for each terminal, in terms of the terminal's token.
   */
  balanceOf(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
   * Gets the current overflowed amount in a terminal for a specified project.
   * @param _projectId The ID of the project to get overflow for.
   * @param _terminal The terminal for which the overflow is being calculated.
   */
  currentOverflowOf(
    _terminal: string,
    _projectId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
   * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
   * @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
   * @param _projectId The ID of the project to get the reclaimable overflow amount for.
   * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
   * @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
   */
  "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)"(
    _projectId: BigNumberish,
    _tokenCount: BigNumberish,
    _totalSupply: BigNumberish,
    _overflow: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.The current reclaimable overflow is returned in terms of the specified terminal's currency.The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
   * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
   * @param _projectId The ID of the project to get the reclaimable overflow amount for.
   * @param _terminal The terminal from which the reclaimable amount would come.
   * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
   * @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
   */
  "currentReclaimableOverflowOf(address,uint256,uint256,bool)"(
    _terminal: string,
    _projectId: BigNumberish,
    _tokenCount: BigNumberish,
    _useTotalOverflow: boolean,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the current overflowed amount for a specified project across all terminals.
   * @param _currency The currency that the total overflow should be in terms of.
   * @param _decimals The number of decimals that the fixed point overflow should include.
   * @param _projectId The ID of the project to get total overflow for.
   */
  currentTotalOverflowOf(
    _projectId: BigNumberish,
    _decimals: BigNumberish,
    _currency: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The directory of terminals and controllers for projects.
   */
  directory(overrides?: CallOverrides): Promise<string>;

  /**
   * The contract storing all funding cycle configurations.
   */
  fundingCycleStore(overrides?: CallOverrides): Promise<string>;

  /**
   * The contract that exposes price feeds.
   */
  prices(overrides?: CallOverrides): Promise<string>;

  /**
   * The msg.sender must be an IJBSingleTokenPaymentTerminal.
   * Records newly added funds for the project.
   * @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
   * @param _projectId The ID of the project to which the funds being added belong.
   */
  recordAddedBalanceFor(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The msg.sender must be an IJBSingleTokenPaymentTerminal.
   * Records newly distributed funds for a project.
   * @param _amount The amount to use from the distribution limit, as a fixed point number.
   * @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
   * @param _projectId The ID of the project that is having funds distributed.
   */
  recordDistributionFor(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    _currency: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
   * Records the migration of funds from this store.
   * @param _projectId The ID of the project being migrated.
   */
  recordMigration(
    _projectId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  recordPaymentFrom(
    _payer: string,
    _amount: JBTokenAmountStruct,
    _projectId: BigNumberish,
    _baseWeightCurrency: BigNumberish,
    _beneficiary: string,
    _memo: string,
    _metadata: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
   * Records newly redeemed tokens of a project.
   * @param _holder The account that is having its tokens redeemed.
   * @param _memo A memo to pass along to the emitted event.
   * @param _metadata Bytes to send along to the data source, if one is provided.
   * @param _projectId The ID of the project to which the tokens being redeemed belong.
   * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
   */
  recordRedemptionFor(
    _holder: string,
    _projectId: BigNumberish,
    _tokenCount: BigNumberish,
    _memo: string,
    _metadata: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The msg.sender must be an IJBSingleTokenPaymentTerminal.
   * Records newly used allowance funds of a project.
   * @param _amount The amount to use from the allowance, as a fixed point number.
   * @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
   * @param _projectId The ID of the project to use the allowance of.
   */
  recordUsedAllowanceOf(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    _currency: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
   */
  usedDistributionLimitOf(
    arg0: string,
    arg1: BigNumberish,
    arg2: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
   */
  usedOverflowAllowanceOf(
    arg0: string,
    arg1: BigNumberish,
    arg2: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    /**
     * The amount of tokens that each project has for each terminal, in terms of the terminal's token.
     */
    balanceOf(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * Gets the current overflowed amount in a terminal for a specified project.
     * @param _projectId The ID of the project to get overflow for.
     * @param _terminal The terminal for which the overflow is being calculated.
     */
    currentOverflowOf(
      _terminal: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
     * @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     */
    "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)"(
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _totalSupply: BigNumberish,
      _overflow: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.The current reclaimable overflow is returned in terms of the specified terminal's currency.The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _terminal The terminal from which the reclaimable amount would come.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
     */
    "currentReclaimableOverflowOf(address,uint256,uint256,bool)"(
      _terminal: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _useTotalOverflow: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the current overflowed amount for a specified project across all terminals.
     * @param _currency The currency that the total overflow should be in terms of.
     * @param _decimals The number of decimals that the fixed point overflow should include.
     * @param _projectId The ID of the project to get total overflow for.
     */
    currentTotalOverflowOf(
      _projectId: BigNumberish,
      _decimals: BigNumberish,
      _currency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<string>;

    /**
     * The contract storing all funding cycle configurations.
     */
    fundingCycleStore(overrides?: CallOverrides): Promise<string>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<string>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly added funds for the project.
     * @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
     * @param _projectId The ID of the project to which the funds being added belong.
     */
    recordAddedBalanceFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly distributed funds for a project.
     * @param _amount The amount to use from the distribution limit, as a fixed point number.
     * @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
     * @param _projectId The ID of the project that is having funds distributed.
     */
    recordDistributionFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [JBFundingCycleStructOutput, BigNumber] & {
        fundingCycle: JBFundingCycleStructOutput;
        distributedAmount: BigNumber;
      }
    >;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
     * Records the migration of funds from this store.
     * @param _projectId The ID of the project being migrated.
     */
    recordMigration(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    recordPaymentFrom(
      _payer: string,
      _amount: JBTokenAmountStruct,
      _projectId: BigNumberish,
      _baseWeightCurrency: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        JBFundingCycleStructOutput,
        BigNumber,
        JBPayDelegateAllocationStructOutput[],
        string
      ] & {
        fundingCycle: JBFundingCycleStructOutput;
        tokenCount: BigNumber;
        delegateAllocations: JBPayDelegateAllocationStructOutput[];
        memo: string;
      }
    >;

    /**
     * Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
     * Records newly redeemed tokens of a project.
     * @param _holder The account that is having its tokens redeemed.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, if one is provided.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    recordRedemptionFor(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _memo: string,
      _metadata: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        JBFundingCycleStructOutput,
        BigNumber,
        JBRedemptionDelegateAllocationStructOutput[],
        string
      ] & {
        fundingCycle: JBFundingCycleStructOutput;
        reclaimAmount: BigNumber;
        delegateAllocations: JBRedemptionDelegateAllocationStructOutput[];
        memo: string;
      }
    >;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly used allowance funds of a project.
     * @param _amount The amount to use from the allowance, as a fixed point number.
     * @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
     * @param _projectId The ID of the project to use the allowance of.
     */
    recordUsedAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [JBFundingCycleStructOutput, BigNumber] & {
        fundingCycle: JBFundingCycleStructOutput;
        usedAmount: BigNumber;
      }
    >;

    /**
     * The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
     */
    usedDistributionLimitOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
     */
    usedOverflowAllowanceOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    /**
     * The amount of tokens that each project has for each terminal, in terms of the terminal's token.
     */
    balanceOf(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * Gets the current overflowed amount in a terminal for a specified project.
     * @param _projectId The ID of the project to get overflow for.
     * @param _terminal The terminal for which the overflow is being calculated.
     */
    currentOverflowOf(
      _terminal: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
     * @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     */
    "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)"(
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _totalSupply: BigNumberish,
      _overflow: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.The current reclaimable overflow is returned in terms of the specified terminal's currency.The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _terminal The terminal from which the reclaimable amount would come.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
     */
    "currentReclaimableOverflowOf(address,uint256,uint256,bool)"(
      _terminal: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _useTotalOverflow: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the current overflowed amount for a specified project across all terminals.
     * @param _currency The currency that the total overflow should be in terms of.
     * @param _decimals The number of decimals that the fixed point overflow should include.
     * @param _projectId The ID of the project to get total overflow for.
     */
    currentTotalOverflowOf(
      _projectId: BigNumberish,
      _decimals: BigNumberish,
      _currency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The contract storing all funding cycle configurations.
     */
    fundingCycleStore(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly added funds for the project.
     * @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
     * @param _projectId The ID of the project to which the funds being added belong.
     */
    recordAddedBalanceFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly distributed funds for a project.
     * @param _amount The amount to use from the distribution limit, as a fixed point number.
     * @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
     * @param _projectId The ID of the project that is having funds distributed.
     */
    recordDistributionFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
     * Records the migration of funds from this store.
     * @param _projectId The ID of the project being migrated.
     */
    recordMigration(
      _projectId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    recordPaymentFrom(
      _payer: string,
      _amount: JBTokenAmountStruct,
      _projectId: BigNumberish,
      _baseWeightCurrency: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
     * Records newly redeemed tokens of a project.
     * @param _holder The account that is having its tokens redeemed.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, if one is provided.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    recordRedemptionFor(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly used allowance funds of a project.
     * @param _amount The amount to use from the allowance, as a fixed point number.
     * @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
     * @param _projectId The ID of the project to use the allowance of.
     */
    recordUsedAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
     */
    usedDistributionLimitOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
     */
    usedOverflowAllowanceOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The amount of tokens that each project has for each terminal, in terms of the terminal's token.
     */
    balanceOf(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * Gets the current overflowed amount in a terminal for a specified project.
     * @param _projectId The ID of the project to get overflow for.
     * @param _terminal The terminal for which the overflow is being calculated.
     */
    currentOverflowOf(
      _terminal: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
     * @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     */
    "currentReclaimableOverflowOf(uint256,uint256,uint256,uint256)"(
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _totalSupply: BigNumberish,
      _overflow: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     *  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.The current reclaimable overflow is returned in terms of the specified terminal's currency.The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
     * The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
     * @param _projectId The ID of the project to get the reclaimable overflow amount for.
     * @param _terminal The terminal from which the reclaimable amount would come.
     * @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
     * @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
     */
    "currentReclaimableOverflowOf(address,uint256,uint256,bool)"(
      _terminal: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _useTotalOverflow: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the current overflowed amount for a specified project across all terminals.
     * @param _currency The currency that the total overflow should be in terms of.
     * @param _decimals The number of decimals that the fixed point overflow should include.
     * @param _projectId The ID of the project to get total overflow for.
     */
    currentTotalOverflowOf(
      _projectId: BigNumberish,
      _decimals: BigNumberish,
      _currency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The contract storing all funding cycle configurations.
     */
    fundingCycleStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly added funds for the project.
     * @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
     * @param _projectId The ID of the project to which the funds being added belong.
     */
    recordAddedBalanceFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly distributed funds for a project.
     * @param _amount The amount to use from the distribution limit, as a fixed point number.
     * @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
     * @param _projectId The ID of the project that is having funds distributed.
     */
    recordDistributionFor(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
     * Records the migration of funds from this store.
     * @param _projectId The ID of the project being migrated.
     */
    recordMigration(
      _projectId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    recordPaymentFrom(
      _payer: string,
      _amount: JBTokenAmountStruct,
      _projectId: BigNumberish,
      _baseWeightCurrency: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
     * Records newly redeemed tokens of a project.
     * @param _holder The account that is having its tokens redeemed.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, if one is provided.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    recordRedemptionFor(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The msg.sender must be an IJBSingleTokenPaymentTerminal.
     * Records newly used allowance funds of a project.
     * @param _amount The amount to use from the allowance, as a fixed point number.
     * @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
     * @param _projectId The ID of the project to use the allowance of.
     */
    recordUsedAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
     */
    usedDistributionLimitOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
     */
    usedOverflowAllowanceOf(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
